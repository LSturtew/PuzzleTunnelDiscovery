#!/usr/bin/env python3

'''
Print the pair (edge) of RDT trees that share the same sample in the same PreDefined sample Set (PDS).
These files are generated by `se3solver.py solve --samset` or `se3solver.py solve --samset2`

Note:
    This application does NOT (and ARE NOT ABLE TO) check the same PDS is used.
    User is responsible to guarantee this.
'''

import argparse
import numpy as np
from scipy.io import loadmat
import h5py
import scipy.sparse as sparse
from progressbar import progressbar

def print_edge_sparse(args):
    cl = []
    for fn in progressbar(args.files):
        cl.append(loadmat(fn)['C'])
    print("Stacking sparse matrices")
    mc = sparse.vstack(cl, format='csr')
    print("Colwise summing")
    cws = mc.sum(axis=0)
    nv = cws.shape[1]
    #print(cws.shape)
    edges = sparse.lil_matrix((nv, nv), dtype=np.int8)
    for i in progressbar(range(nv)):
        s = cws[0,i]
        if s < 2:
            continue
        rows,_ = mc[:,i].nonzero()
        '''
        for r,c in zip(rows[:-1], rows[1:]):
            edges[r,c] = 1
            #print("{},{}".format(r,c))
        '''
    #savemat(args.out, dict(E=edges), do_compression=True)

def print_edge(args):
    OPENSPACE_FLAG = 1
    if args.pdsflags is not None:
        QF = np.load(args.pdsflags)['QF']
    else:
        QF = None
    E = None
    r = 0
    f = h5py.File(args.out, mode='a')
    for fn in progressbar(args.files):
        rowdata = loadmat(fn)['C']
        if E is None:
            E = np.zeros((len(args.files), rowdata.shape[1]), dtype=np.int8)
        E[r] = rowdata.todense()
        r += 1
    root_from, pds_to = E.nonzero()
    forest_edge = np.transpose(np.array([root_from, pds_to], dtype=np.int32))
    if 'FE' in f:
        del f['FE']
    f.create_dataset('FE', data=forest_edge, compression='lzf')
    f.flush()
    del forest_edge
    cws = E.sum(axis=0)
    nv = cws.shape[0]
    Edense = np.zeros((len(args.files), len(args.files)), dtype=np.int32)
    for i in progressbar(range(nv)):
        s = cws[i]
        if s < 2:
            continue
        rows = np.nonzero(E[:,i])[0].tolist()
        edge_from = rows[:-1]
        edge_to = rows[1:]
        Edense[edge_from, edge_to] = i
    roots_to_open = set()
    if QF is not None:
        for i in progressbar(range(nv)):
            if QF[i] & OPENSPACE_FLAG == 0:
                continue
            rows = np.nonzero(E[:,i])[0].tolist()
            roots_to_open.update(rows)
    del cws
    del E
    # edge = np.transpose(np.array([edge_from, edge_to], dtype=np.int32))
    # print("Uniquing the edge pairs")
    # edge = np.unique(edge, axis=0)
    # del edge_from
    # del edge_to
    edge_from, edge_to = Edense.nonzero()
    roots_to_open_list = np.array(list(roots_to_open), dtype=np.int64)
    '''
    if len(roots_to_open) >= 2:
        # Add a chain that connects all roots with openspace leaf.
        # This is not enough for path planning, but good enough for disjoint set algorithm
        edge_from = np.append(edge_from, roots_to_open_list[:-1])
        edge_to = np.append(edge_to, roots_to_open_list[1:])
    '''
    edge = np.transpose(np.array([edge_from, edge_to, Edense[edge_from, edge_to]], dtype=np.int32))
    #savemat(args.out, dict(E=edge, FE=forest_edge), do_compression=True)
    if 'E' in f:
        del f['E']
    f.create_dataset('E', data=edge, compression='lzf')
    if 'OpenTree' in f:
        del f['OpenTree']
    f.create_dataset('OpenTree', data=roots_to_open_list, compression='lzf')
    f.close()

def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('files', help='ssc-*.mat file', nargs='+')
    parser.add_argument('--out', help='output edge file in .hdf5', required=True)
    parser.add_argument('--pdsflags', help='File that stores PDS Flags, usually in the same npz file that also stores PDS', default=None)
    args = parser.parse_args()
    if not args.out.endswith('.hdf5'):
        print("--out requires hdf5 extension")
        return
    print_edge(args)

if __name__ == '__main__':
    main()
